"""
Утилиты для нормализации адресов
"""
import re

# Регулярное выражение для поиска номера дома
# Поддерживает: 33, 33а, 33/1, 33 корпус 1, 33-а и т.п.
# Паттерн: число + опциональная буква + опциональный дефис/слэш + опциональный корпус
_house_rx = re.compile(r"(?<!\d)(\d+[а-яa-z]?(?:[-\/]\d+[а-яa-z]?)?(?:\s*к[оо]рп\.?\s*\d+[а-яa-z]?)?|\d+\s*к[оо]рп\.?\s*\d+[а-яa-z]?|\d+[-\/][а-яa-z])(?!\d)", re.IGNORECASE)


def normalize_text(s: str) -> str:
    """
    Нормализует текст адреса для парсинга.
    
    Убирает префиксы типа "г.", "ул.", "пр-т", приводит к нижнему регистру,
    удаляет лишние символы, нормализует пробелы.
    
    Args:
        s: Исходный текст адреса
        
    Returns:
        Нормализованный текст
    """
    if not s:
        return ""
    s = s.lower().strip()
    # Убираем префиксы с пробелами после них
    s = re.sub(r"\b(г\.|город)\s*", "", s)
    s = re.sub(r"\b(ул\.|улица)\s*", "", s)
    s = re.sub(r"\b(пр-т|проспект)\s*", "проспект ", s)
    # Сохраняем дефисы и слэши для номеров домов типа 33-а, 33/1
    s = re.sub(r"[^\w\d\s,.\-/]", "", s)  # удалить лишние символы, но сохранить дефис и слэш
    s = re.sub(r"\s+", " ", s).strip()
    return s


def normalize_address(address: str) -> str:
    """
    Нормализует адрес для группировки объявлений (обратная совместимость).
    
    Args:
        address: Исходный адрес
        
    Returns:
        Нормализованный адрес
    """
    return normalize_text(address)


def split_address(address: str) -> dict:
    """
    Разбивает адрес на улицу и номер дома.
    
    Возвращает словарь с ключами:
    - street: нормализованное название улицы (без номера дома)
    - house: номер дома (если найден), иначе пустая строка
    
    Поддерживает различные форматы номеров домов:
    - 33
    - 33а
    - 33/1
    - 33 корпус 1
    - 33-а
    
    Args:
        address: Исходный адрес
        
    Returns:
        Словарь {"street": str, "house": str}
    """
    s = normalize_text(address)
    if not s:
        return {"street": "", "house": ""}

    # Ищем номер дома: число + опциональная буква/дефис/слэш + опциональный корпус
    # Паттерн 1: число + корпус + число (приоритет выше, чтобы не захватывать только первое число)
    # Используем более широкий паттерн для слова "корпус"
    pattern1 = r"(?<!\d)(\d+\s*к[оо]рп[уу]с\.?\s*\d+[а-яa-z]?)"
    # Паттерн 2: число + дефис + буква
    pattern2 = r"(?<!\d)(\d+[-][а-яa-z])"
    # Паттерн 3: число + буква/дефис/слэш + опциональный корпус
    pattern3 = r"(?<!\d)(\d+[а-яa-z]?(?:[-\/]\d+[а-яa-z]?)?(?:\s*к[оо]рп[уу]с\.?\s*\d+[а-яa-z]?)?)"
    # Паттерн 4: просто число
    pattern4 = r"(?<!\d)(\d+)(?!\d)"
    
    m = None
    house = ""
    
    # Пробуем найти по порядку приоритета
    for pattern in [pattern2, pattern3, pattern1, pattern4]:
        m = re.search(pattern, s, re.IGNORECASE)
        if m:
            house = m.group(1).strip()
            break
    
    street = s
    if house:
        # Очистить street от найденного номера и лишних символов
        street = (s[:m.start()] + s[m.end():]).strip(" ,-")
        # Убираем двойные пробелы и запятые в начале/конце
        street = re.sub(r"\s+", " ", street).strip(" ,")
    
    return {"street": street, "house": house}
